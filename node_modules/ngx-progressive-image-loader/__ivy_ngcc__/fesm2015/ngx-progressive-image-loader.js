import { isPlatformBrowser } from '@angular/common';
import { WINDOW } from 'ngx-window-token';
import { DomSanitizer } from '@angular/platform-browser';
import { InjectionToken, Inject, Injectable, ChangeDetectionStrategy, Component, Input, Optional, PLATFORM_ID, Renderer2, HostBinding, Directive, ElementRef, EventEmitter, Output, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/platform-browser';

const _c0 = ["*"];
const IMAGE_LOADER_CONFIG_TOKEN = new InjectionToken('Image loader Config');
/** @type {?} */
const DEFAULT_IMAGE_LOADER_OPTIONS = (/** @type {?} */ ({
    // root?: Element | null;
    rootMargin: '10px',
    threshold: [0.1, 0.5, 1],
    imageRatio: 16 / 9,
    placeholderImageSrc: '',
    isAggressiveLoading: true,
    concurrentLoading: 4
}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ConfigurationService {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.setConfig(options);
    }
    /**
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        if (config) {
            this.config = Object.assign({}, DEFAULT_IMAGE_LOADER_OPTIONS, config);
        }
        else {
            this.config = DEFAULT_IMAGE_LOADER_OPTIONS;
        }
    }
}
ConfigurationService.ɵfac = function ConfigurationService_Factory(t) { return new (t || ConfigurationService)(ɵngcc0.ɵɵinject(IMAGE_LOADER_CONFIG_TOKEN)); };
ConfigurationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ConfigurationService, factory: ConfigurationService.ɵfac });
/** @nocollapse */
ConfigurationService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IMAGE_LOADER_CONFIG_TOKEN,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ConfigurationService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IMAGE_LOADER_CONFIG_TOKEN]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} window
 * @return {?}
 */
function isSupportIntersectionObserver(window) {
    return (window &&
        'IntersectionObserver' in window &&
        'IntersectionObserverEntry' in window &&
        'intersectionRatio' in window.IntersectionObserverEntry.prototype);
}
/**
 * @param {?} element
 * @return {?}
 */
function isImagePicture(element) {
    return element instanceof HTMLImageElement || element instanceof HTMLPictureElement;
}
/**
 * @param {?} renderer
 * @param {?} attribute
 * @param {?} element
 * @return {?}
 */
function setAttribute(renderer, attribute, element) {
    renderer.setAttribute(element, attribute, element.dataset[attribute]);
    // maybe doesn't matter
    // renderer.removeAttribute(element, 'data-' + attribute);
}
/**
 * @param {?} element
 * @return {?}
 */
function isPictureElement(element) {
    return element.nodeName === 'PICTURE';
}
/**
 * @param {?} renderer
 * @param {?} image
 * @return {?}
 */
function loadImage(renderer, image) {
    if (isPictureElement(image.parentElement)) {
        /** @type {?} */
        const sourceElms = image.parentElement.children;
        for (let index = 0; index < sourceElms.length; index++) {
            /** @type {?} */
            const element = sourceElms[index];
            if (element instanceof HTMLSourceElement) {
                setAttribute(renderer, 'srcset', element);
            }
            else if (element instanceof HTMLImageElement) {
                setAttribute(renderer, 'src', element);
            }
        }
    }
    else {
        if (image.dataset.src) {
            setAttribute(renderer, 'src', image);
        }
        if (image.dataset.srcset) {
            setAttribute(renderer, 'srcset', image);
        }
    }
}
/**
 * @param {?} window
 * @return {?}
 */
function isSpider(window) {
    return ((window && !('onscroll' in window)) ||
        /(gle|ing|ro)bot|crawl|spider/i.test(window.navigator.userAgent));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProgressiveImageLoaderComponent {
    /**
     * @param {?} _Renderer
     * @param {?} _ConfigurationService
     * @param {?} platformId
     * @param {?} window
     */
    constructor(_Renderer, _ConfigurationService, platformId, window) {
        this._Renderer = _Renderer;
        this._ConfigurationService = _ConfigurationService;
        this.platformId = platformId;
        this.window = window;
        // to store observed images
        this.targetMap = new Map();
        // to maintain the sequence of observed images
        this.targetQueue = (/** @type {?} */ ([]));
        // counter of current loading images
        this.loading = 0;
    }
    /**
     * @return {?}
     */
    get isObservable() {
        return !!this.intersectionObserver;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isAggressiveLoading === undefined) {
            this.isAggressiveLoading = this._ConfigurationService.config.isAggressiveLoading;
        }
        if (this.concurrentLoading === undefined) {
            this.concurrentLoading = this._ConfigurationService.config.concurrentLoading;
        }
        if (this.window &&
            isSupportIntersectionObserver(this.window) &&
            !isSpider(this.window) &&
            isPlatformBrowser(this.platformId)) {
            if (!this.imageRatio) {
                this.imageRatio = this._ConfigurationService.config.imageRatio;
            }
            if (!this.filter) {
                this.filter = this._ConfigurationService.config.filter;
            }
            if (!this.placeholderImageSrc) {
                this.placeholderImageSrc = this._ConfigurationService.config.placeholderImageSrc;
            }
            this.intersectionObserver = new IntersectionObserver(this.onIntersectionChanged.bind(this), this._ConfigurationService.config);
        }
    }
    /**
     * @param {?} target
     * @return {?}
     */
    observe(target) {
        // so intersection observer can always detect it correctly, otherwise image elements with 0 in height sometime don't load correctly
        target.style.minHeight = '1rem';
        this.intersectionObserver.observe(target);
        this.targetMap.set(target.dataset.src, target);
        this.targetQueue.push(target.dataset.src);
    }
    /**
     * @param {?} target
     * @return {?}
     */
    unobserve(target) {
        target.style.minHeight = 'initial';
        this.targetMap.delete(target.dataset.src);
        this.intersectionObserver.unobserve(target);
    }
    // called after an image loaded
    /**
     * @return {?}
     */
    imageLoaded() {
        this.loading--;
        while (this.isAggressiveLoading &&
            this.targetQueue &&
            this.targetQueue.length &&
            this.loading <= this.concurrentLoading) {
            /** @type {?} */
            const next = this.targetQueue.shift();
            this.targetMap.has(next) && this.loadImage(this.targetMap.get(next));
        }
    }
    /**
     * @param {?} entries
     * @param {?} observer
     * @return {?}
     */
    onIntersectionChanged(entries, observer) {
        entries.forEach((/**
         * @param {?} entry
         * @return {?}
         */
        entry => {
            if (entry.isIntersecting) {
                this.loadImage((/** @type {?} */ (entry.target)));
            }
        }));
    }
    // start loading an image
    /**
     * @param {?} image
     * @return {?}
     */
    loadImage(image) {
        // Stop observing the current target
        this.unobserve(image);
        this.loading++;
        loadImage(this._Renderer, image);
    }
    /**
     * @return {?}
     */
    reset() {
        this.targetQueue = [];
        this.targetMap = new Map();
        this.isObservable && this.intersectionObserver.disconnect();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.isObservable && this.intersectionObserver.disconnect();
        this.intersectionObserver = this.targetQueue = this.targetMap = undefined;
    }
}
ProgressiveImageLoaderComponent.ɵfac = function ProgressiveImageLoaderComponent_Factory(t) { return new (t || ProgressiveImageLoaderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(WINDOW, 8)); };
ProgressiveImageLoaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ProgressiveImageLoaderComponent, selectors: [["ngx-progressive-image-loader"]], inputs: { isAggressiveLoading: "isAggressiveLoading", concurrentLoading: "concurrentLoading", imageRatio: "imageRatio", filter: "filter", placeholderImageSrc: "placeholderImageSrc" }, exportAs: ["ngxProgressiveImageLoader"], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ProgressiveImageLoaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
ProgressiveImageLoaderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ConfigurationService },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [WINDOW,] }] }
];
ProgressiveImageLoaderComponent.propDecorators = {
    imageRatio: [{ type: Input }],
    concurrentLoading: [{ type: Input }],
    isAggressiveLoading: [{ type: Input }],
    filter: [{ type: Input }],
    placeholderImageSrc: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ProgressiveImageLoaderComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-progressive-image-loader',
                exportAs: 'ngxProgressiveImageLoader',
                template: `
    <ng-content></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ConfigurationService }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [WINDOW]
            }] }]; }, { isAggressiveLoading: [{
            type: Input
        }], concurrentLoading: [{
            type: Input
        }], imageRatio: [{
            type: Input
        }], filter: [{
            type: Input
        }], placeholderImageSrc: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImagePlaceholderComponent {
    /**
     * @param {?} sanitizer
     * @param {?} _ProgressiveImageLoader
     */
    constructor(sanitizer, _ProgressiveImageLoader) {
        this.sanitizer = sanitizer;
        this._ProgressiveImageLoader = _ProgressiveImageLoader;
        this.class = 'ngx-image-placeholder';
    }
    /**
     * @return {?}
     */
    get placeHolder() {
        return this.sanitizer.bypassSecurityTrustStyle(`padding-bottom: ${100 / (this.imageRatio || this._ProgressiveImageLoader.imageRatio)}%;`);
    }
    /**
     * @return {?}
     */
    get imageFilter() {
        return this.sanitizer.bypassSecurityTrustStyle(`${this._ProgressiveImageLoader.filter}`);
    }
    /**
     * @return {?}
     */
    get safeLoadingImage() {
        return this.sanitizer.bypassSecurityTrustUrl(this.placeholderImageSrc || this._ProgressiveImageLoader.placeholderImageSrc);
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
ImagePlaceholderComponent.ɵfac = function ImagePlaceholderComponent_Factory(t) { return new (t || ImagePlaceholderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(ProgressiveImageLoaderComponent)); };
ImagePlaceholderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ImagePlaceholderComponent, selectors: [["ngx-image-placeholder"]], hostVars: 4, hostBindings: function ImagePlaceholderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleMap(ctx.placeHolder);
        ɵngcc0.ɵɵclassMap(ctx.class);
    } }, inputs: { imageRatio: "imageRatio", placeholderImageSrc: "placeholderImageSrc" }, ngContentSelectors: _c0, decls: 2, vars: 3, consts: [[1, "placeholder-loading-image", 3, "src"]], template: function ImagePlaceholderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "img", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("filter", ctx.imageFilter, ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵproperty("src", ctx.safeLoadingImage, ɵngcc0.ɵɵsanitizeUrl);
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
ImagePlaceholderComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: ProgressiveImageLoaderComponent }
];
ImagePlaceholderComponent.propDecorators = {
    class: [{ type: HostBinding, args: ['class',] }],
    placeHolder: [{ type: HostBinding, args: ['style',] }],
    imageRatio: [{ type: Input }],
    placeholderImageSrc: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ImagePlaceholderComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-image-placeholder',
                template: `
    <img class="placeholder-loading-image" [src]="safeLoadingImage" [style.filter]="imageFilter" />
    <ng-content></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc1.DomSanitizer }, { type: ProgressiveImageLoaderComponent }]; }, { class: [{
            type: HostBinding,
            args: ['class']
        }], placeHolder: [{
            type: HostBinding,
            args: ['style']
        }], imageRatio: [{
            type: Input
        }], placeholderImageSrc: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProgressiveImageDirective {
    /**
     * @param {?} _ElementRef
     * @param {?} _Renderer
     * @param {?} _ConfigurationService
     * @param {?} _ImagePlaceholder
     * @param {?} _ProgressiveImageLoader
     */
    constructor(_ElementRef, _Renderer, _ConfigurationService, _ImagePlaceholder, _ProgressiveImageLoader) {
        this._ElementRef = _ElementRef;
        this._Renderer = _Renderer;
        this._ConfigurationService = _ConfigurationService;
        this._ImagePlaceholder = _ImagePlaceholder;
        this._ProgressiveImageLoader = _ProgressiveImageLoader;
        this.noPlaceholder = false;
        this.onImageLoaded = new EventEmitter();
        this.isObserved = false;
    }
    // to create a placeholder before finish loading the real image to avoid reflow
    /**
     * @param {?} value
     * @return {?}
     */
    set imageRatio(value) {
        this._imageRatio = value;
    }
    /**
     * @return {?}
     */
    get imageRatio() {
        return this._imageRatio || this._ProgressiveImageLoader.imageRatio;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set placeholderImageSrc(value) {
        this._placeholderImageSrc = value;
    }
    /**
     * @return {?}
     */
    get placeholderImageSrc() {
        return this._placeholderImageSrc || this._ProgressiveImageLoader.placeholderImageSrc;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.imageElement = this._ElementRef.nativeElement;
        this.setDataSrc('data-src', this.src);
        this.setDataSrc('data-srcset', this.srcset);
        if (this._ProgressiveImageLoader.isObservable) {
            // only image element need to be observe and have onload event
            if (this.imageElement instanceof HTMLImageElement) {
                this.isObserved = true;
                this._ProgressiveImageLoader.observe(this.imageElement);
                this.imageElement.onload = (/**
                 * @return {?}
                 */
                () => {
                    this.onImageLoaded.emit(this.imageElement);
                    this.imageElement.classList.add('loaded');
                    this._ProgressiveImageLoader.imageLoaded();
                });
                if (!this._ImagePlaceholder && !this.noPlaceholder) {
                    this.setPlaceholder();
                }
            }
        }
        else {
            // show image directly
            loadImage(this._Renderer, this.imageElement);
            this.imageElement.classList.add('loaded');
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        changes.src && !changes.src.isFirstChange() && this.setDataSrc('data-src', this.src);
        changes.srcset &&
            !changes.srcset.isFirstChange() &&
            this.setDataSrc('data-srcset', this.srcset);
        if (this.isObserved &&
            ((changes.src && !changes.src.isFirstChange()) ||
                (changes.srcset && !changes.srcset.isFirstChange()))) {
            this._ProgressiveImageLoader.unobserve(this.imageElement);
            this._ProgressiveImageLoader.observe(this.imageElement);
        }
    }
    /**
     * @param {?} attr
     * @param {?} value
     * @return {?}
     */
    setDataSrc(attr, value) {
        value && this._Renderer.setAttribute(this.imageElement, attr, value);
    }
    /**
     * @return {?}
     */
    setPlaceholder() {
        /** @type {?} */
        const parentElement = this.imageElement.parentElement;
        /** @type {?} */
        const placeholder = this.createPlaceholder(this.createPlaceholderImage());
        if (isPictureElement(parentElement)) {
            /** @type {?} */
            const pictureParent = parentElement.parentElement;
            this.insertPlaceholder(pictureParent, parentElement, placeholder);
        }
        else {
            this.insertPlaceholder(parentElement, this.imageElement, placeholder);
        }
    }
    /**
     * @private
     * @param {?} parentElement
     * @param {?} imagePicture
     * @param {?} placeholder
     * @return {?}
     */
    insertPlaceholder(parentElement, imagePicture, placeholder) {
        parentElement.insertBefore(placeholder, imagePicture);
        placeholder.style.paddingBottom = `${100 / this.imageRatio}%`;
        placeholder.appendChild(imagePicture);
    }
    /**
     * @private
     * @param {?} placeholderImage
     * @return {?}
     */
    createPlaceholder(placeholderImage) {
        /** @type {?} */
        const placeholder = document.createElement('div');
        placeholder.classList.add('ngx-image-placeholder');
        placeholder.appendChild(placeholderImage);
        return placeholder;
    }
    /**
     * @return {?}
     */
    createPlaceholderImage() {
        /** @type {?} */
        const img = new Image();
        img.classList.add('placeholder-loading-image');
        img.style.filter = this._ProgressiveImageLoader.filter;
        img.src = this.placeholderImageSrc;
        return img;
    }
}
ProgressiveImageDirective.ɵfac = function ProgressiveImageDirective_Factory(t) { return new (t || ProgressiveImageDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(ImagePlaceholderComponent, 8), ɵngcc0.ɵɵdirectiveInject(ProgressiveImageLoaderComponent)); };
ProgressiveImageDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ProgressiveImageDirective, selectors: [["img", "ngxProgressiveImage", ""], ["source", "ngxProgressiveImage", ""]], inputs: { noPlaceholder: "noPlaceholder", imageRatio: "imageRatio", placeholderImageSrc: "placeholderImageSrc", src: "src", srcset: "srcset" }, outputs: { onImageLoaded: "onImageLoaded" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
ProgressiveImageDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ConfigurationService },
    { type: ImagePlaceholderComponent, decorators: [{ type: Optional }, { type: Inject, args: [ImagePlaceholderComponent,] }] },
    { type: ProgressiveImageLoaderComponent, decorators: [{ type: Inject, args: [ProgressiveImageLoaderComponent,] }] }
];
ProgressiveImageDirective.propDecorators = {
    imageRatio: [{ type: Input }],
    placeholderImageSrc: [{ type: Input }],
    src: [{ type: Input }],
    srcset: [{ type: Input }],
    noPlaceholder: [{ type: Input }],
    onImageLoaded: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ProgressiveImageDirective, [{
        type: Directive,
        args: [{
                // make sure the element is an image element
                selector: 'img[ngxProgressiveImage], source[ngxProgressiveImage]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ConfigurationService }, { type: ImagePlaceholderComponent, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ImagePlaceholderComponent]
            }] }, { type: ProgressiveImageLoaderComponent, decorators: [{
                type: Inject,
                args: [ProgressiveImageLoaderComponent]
            }] }]; }, { noPlaceholder: [{
            type: Input
        }], onImageLoaded: [{
            type: Output
        }], imageRatio: [{
            type: Input
        }], placeholderImageSrc: [{
            type: Input
        }], src: [{
            type: Input
        }], srcset: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} options
 * @return {?}
 */
function ConfigurationServiceFactory(options) {
    return new ConfigurationService(options);
}
class NgxProgressiveImageLoaderModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: NgxProgressiveImageLoaderModule,
            providers: [
                { provide: IMAGE_LOADER_CONFIG_TOKEN, useValue: config },
                {
                    provide: ConfigurationService,
                    useFactory: ConfigurationServiceFactory,
                    deps: [IMAGE_LOADER_CONFIG_TOKEN]
                }
            ]
        };
    }
}
NgxProgressiveImageLoaderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxProgressiveImageLoaderModule });
NgxProgressiveImageLoaderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxProgressiveImageLoaderModule_Factory(t) { return new (t || NgxProgressiveImageLoaderModule)(); }, imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxProgressiveImageLoaderModule, { declarations: [ProgressiveImageLoaderComponent,
        ProgressiveImageDirective,
        ImagePlaceholderComponent], exports: [ProgressiveImageLoaderComponent,
        ProgressiveImageDirective,
        ImagePlaceholderComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxProgressiveImageLoaderModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [
                    ProgressiveImageLoaderComponent,
                    ProgressiveImageDirective,
                    ImagePlaceholderComponent
                ],
                exports: [ProgressiveImageLoaderComponent, ProgressiveImageDirective, ImagePlaceholderComponent]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ProgressiveImageLoaderComponent, ProgressiveImageDirective, ImagePlaceholderComponent, ConfigurationServiceFactory, NgxProgressiveImageLoaderModule, IMAGE_LOADER_CONFIG_TOKEN, DEFAULT_IMAGE_LOADER_OPTIONS, isSupportIntersectionObserver, isImagePicture, setAttribute, isPictureElement, loadImage, isSpider, ConfigurationService as ɵa };

//# sourceMappingURL=ngx-progressive-image-loader.js.map